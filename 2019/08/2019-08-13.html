<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-f9e8cc5d-4e32-43f0-80be-502db5b57829"></attachment><h2>promise</h2><p><br></p><h3>特点</h3><ul><li>promise有三种状态,pending(进行中)、fulfilled（已成功）、rejected（已失败）</li><li>对象的状态不受外界影响</li><li>一旦promise状态改变就不会再发生变化</li><li>如果不设置回调，promise 内部抛出的错误不会被反映到外部</li></ul><p><br></p><h3>基本用法</h3><p><br></p><ul><li>创建一个 promise 实例，接受一个函数作为参数，该函数的两个参数分别为 resolve 和 reject ，他们是两个函数，由JavaScript引擎提供，不用自己部署</li><li>promise 实例生成以后，可以使用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数，接受两个参数，第一个为 resolved 的回调，第二个为 rejected 状态的回调，第二个是可选的</li></ul><p><br></p><h3>常用 api</h3><p><br></p><ul><li><strong>then</strong>  </li><li class="ql-indent-1">接受两个参数，第一个为 resolved 的回调，第二个为 rejected 状态的回调，第二个是可选的	</li><li class="ql-indent-1">当前一个回调函数返回一个 promise 对象时，可以进行链式调用</li><li><strong>catch</strong> </li><li class="ql-indent-1">是 .then(null, rejection) 或者 .then(undefined, rejection) 的别名，用于指定发生错误时的回调函数</li><li class="ql-indent-1">如果 then 方法中的回调函树再运行中抛出错误也会被 catch 方法捕获</li><li class="ql-indent-1">如果 promise 状态已经变成 resolved，再抛出错误是无效的</li><li class="ql-indent-1">promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止</li><li class="ql-indent-1">如果没有使用 catch 方法指定错误处理的回调函数， promise 对象派出的错误不会传递到外层代码，既不会有任何反应</li><li class="ql-indent-1">node 有一个 <strong>unhandleRejection</strong> 事件，专门监听未捕获的 reject 错误</li><li><strong>finally</strong> </li><li class="ql-indent-1">用于只当不管promise 对象最后状态如何， 都会执行的操作</li><li class="ql-indent-1">finally 方法的回调函数不接受任何参数，这表明在 finally 方法里面的操作，应该是与状态无关的，不依赖 promise 的执行结果</li><li><strong>all</strong> </li><li class="ql-indent-1">用于将多个 promise 实例，包装成一个新的 promise 实例</li><li class="ql-indent-1">接受一个数组作为参数，数组中每一项都是一个 promise 实例 （不一定非是数组，但必须具有 iterator 接口，且返回的每个成员都是 promise 实例</li><li class="ql-indent-1">状态由 数组中的子 promise 实例决定，所有都为 fulfilled， 则其为 fulfilled，否则为 rejected</li><li><strong>race</strong> </li><li class="ql-indent-1">同样接受一个数组作为参数</li><li class="ql-indent-1">状态依赖于数组中 最先一个改变状态的 promise</li><li><strong>resolve</strong> </li><li class="ql-indent-1">有时需要将现有对象转为 promise 对象， all</li></ul><p><br></p>